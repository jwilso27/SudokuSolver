Initial notes:
	- Executable named solver
	- Please run this with the Coder Challenge puzzles
	- The report will only discuss the components needed for this week's lab

	From the user's perspective, this program asks for an input puzzle file, a
puzzle type (sudoku or wordoku), and number of rows in the puzzle.  The program
then prints the board from the file (or an error if the file could not be read)
and solves the puzzle, printing the filled board.
	
	Internally, the program uses the user's inputs to create an object of type
Puzzle.  This class contains the following data members:
	- int numRows that saves the number of rows
	- 1D vector of size numRows (inputs) that saves the possible input values
(0-9 default, first row in wordoku)
	- 2D vector of size numRows x numRows (board) to save the current board
	- 2D vector of ints of size numRows x numRows (mask) to save positions that
cannot be changed
	- 3D vector of ints of size numRows x numRows x numRows (possible) where
possible[k][i][j] represents whether or not inputs[k] can be placed at
board[i][j] with 0 (not possible), 1 (possible), or 2 (value on board already
set to this value, i.e. board[i][j]==inputs[k])
		- 1st dimension represents the corresponding input to the inputs vector
		- 2nd dimension represents row on board
		- 3rd dimension represents column on board
		
It then prints the loaded puzzle, using the overloaded operator <<, and calls
function solveMain().  This function solves the puzzle using the following
helper functions:
	- isFull()
		- checks if each position on board is empty
		- returns 1 if there are no empty spaces remaining
	- solve()
		- checks for singleton and single values
		- loops until the board is either full or isn't changing, returning
*this, i.e. updated object
		- uses following functions:
			- setPossible(): sets possible values in 3D vector possible based
on function isValid (from lab 5)
			- isFull() for loop condition
	- solveHard()
		- finds the position on the board with the least number of
possibilities and saves a new board for each of those possibilities in a vector
		- returns the vector of boards, each differing by 1 position
	- isPossible()
		- checks if
			1) there is more than 1 set value for the same input in the same
row or column
			2) there are no set values and no possibilities for an input and a
row or column
		- returns 1 if the puzzle can still be solved with the current board
		
	Using these functions, solveMain() uses solve() to either solve the board or
reduce it as much as possible by filling in necessary moves.  If solve() does
not fill the board, then the program creates a 2D vector of Puzzles that uses
solveHard() to add vectors of puzzles.  This basically add/holds the possible
permutations remaining, generated by looping through recursively to either
continue to find possibilities with that board (i.e. repeat with that board) or
end the loop if a full board is found.  When the solution has been found using
solve() or solveHard(), if needed, the program displays the filled board, again
with the overloaded operator <<.
	I verified the results by testing the program and checking the ouput with multiple puzzles, including:
	- easy.txt, medium.txt, cc1.txt (int 9x9, provided by Prof. Emrich)
	- wordoky.txt (char 9x9, provided by Prof. Emrich for lab 5)
	- sudoku.txt (int 9x9, "World's Hardest Sudoku" from telegraph.co.uk)
	- sudoku16.txt (char 16x16, also used to test lab 5)